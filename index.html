<body></body>
<script src="https://unpkg.com/tone"></script>
<script src="https://cdn.jsdelivr.net/gh/netizenorg/netnet-standard-library/build/nn.min.js?v=1"></script>
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script src="https://algorithmicmusic.online/js/create-spectrum.js"></script>
<script src="https://algorithmicmusic.online/js/create-waveform.js"></script>
<script src="https://cdn.jsdelivr.net/npm/resemblejs@5.0.0/resemble.js"></script>
<script src="https://cdn.jsdelivr.net/npm/midimessage@1.0.5/dist/index.js"></script>
<style>
  body {
    font-family:"helvetica"
  }
  label {
    display: block;
    margin: 0.2rem;
  }
  input[type=range] {
    margin: 0.2rem;
  }

</style>
<script>
/* global Tone, nn, d3, createWaveform, createSpectrum, resemble */

const synth = new Tone.PolySynth().toDestination()

// Ripped from netnet code. Needed more data
function myMIDI (func) {
  if (typeof func !== 'function') {
    console.error('nn.MIDI: requires a callback function, this will run everytime you interact with your MIDI device.')
  }

  function onMIDISuccess (midiAccess) {
    const inputs = midiAccess.inputs.values()
    // midi info from https://github.com/notthetup/midimessage/blob/gh-pages/dist/index.js
    for (const input of inputs) {
      console.log(`nn.MIDI: ${input.name} connected!`)
      input.onmidimessage = (message) => func({
      dev: input.name, chl: message.data[1], val: message.data[2],   
        messageCode: message.data[0] & 0xf0,
      })
    }
  }

  navigator.requestMIDIAccess()
    .then(onMIDISuccess)
    .catch(err => console.error(`nn.MIDI: ${err}`))
}

function intDiv (a, b) {
  return ~~(a/b)
}
  
const sliders = ['red', 'green', 'blue', 'brightness', 'white', 'black']


function newSettings (props) {
  const reset = Tone.Synth.getDefaults()
  synth.set(reset)
  const oscOptions = ['sine', 'square', 'triangle', 'sawtooth', 'pwm', 'pulse']
  const oscPrefix = ['', 'fm', 'am', 'fat']
  const oscType = intDiv(props.red + props.green + props.blue + props.brightness + props.white + props.black, 100)
  const oscPrefixType = oscType < 4 ? intDiv(props.brightness, 25) : 0
  const osc = `${oscPrefix[oscPrefixType]}${oscOptions[oscType]}`
  // Currently using preset from class, will adjust later
  const settings = {
    detune: (props.blue / 100) * 70,
    oscillator: {
      type: osc,
      spread: props.red,
      partial: [],
      harmonicity: 0.5,
      modulationType: 'sine',
      count: 10,
      width: 1,
    },
    envelope: {
      attack: props.green / 255 * 1,
      decay: 0.01,
      sustain: 1,
      attackCurve: 'sine',
      releaseCurve: 'sine',
      release: 0.4
    }
  }
  synth.set(settings)
  
  sliders.forEach((s) => {
    console.log(s)
    document.getElementById(`${s}-input`).value = props[s]
  })
}
  
function displayImage(file) {
  document.getElementById("theImage").src = file.data
  
  resemble(file.data).onComplete(function(props){
    /* {
      "red": 49,
      "green": 5,
      "blue": 3,
      "alpha": 0,
      "brightness": 18,
      "white": 0,
      "black": 3
    } */
    newSettings(props)
  });
}

// Using keys to control

const notes = ['C', 'C#', 'D', 'D#', 'E', "F", "F#", "G", "G#", "A", "A#", "B"]
const numNotes = 12
const keyboardStartOctave = 3
const keyboardKeys = ['a', 'w', 's', 'e', 'd', 'f', 't', 'g', 'y', 'h', 'u', 'j', 'k', 'o', 'l', 'p', ';', '\'']
let keyboardMap = {};
  
keyboardKeys.forEach(function (key, index) {
  // Note to self: using integer division
  keyboardMap[key] = {note: `${notes[index % numNotes]}${keyboardStartOctave + intDiv(index, numNotes)}`}
});

function keyboardAttack (e) {
  // select the object from the keyMap matching the key pressed
  const obj = keyboardMap[e.key]
  // if we found an object and it is "not" pressed...
  if (obj && !obj.pressed) {
    //...then trigger the frequency
    synth.triggerAttack(obj.note)
    obj.pressed = true
  }
}

// here we do the inverse of the function above
function keyboardRelease (e) {
	  const obj = keyboardMap[e.key]
  if (obj && obj.pressed) {
    synth.triggerRelease(obj.note)
    obj.pressed = false
  }
}

const midiStartOctave = 0
const midiKeys = [...Array(128).keys()]
let midiMap = {};
  
midiKeys.forEach(function (key, index) {
  // Note to self: using integer division
  midiMap[key] = {note: `${notes[index % numNotes]}${midiStartOctave + intDiv(index, numNotes)}`}
});
  
function midiAttack (key) {
  // select the object from the keyMap matching the key pressed
  const obj = midiMap[key]
  // if we found an object and it is "not" pressed...
  if (obj && !obj.pressed) {
    //...then trigger the frequency
    synth.triggerAttack(obj.note)
    obj.pressed = true
  }
}
  
function midiRelease (key) {
	  const obj = midiMap[key]
  if (obj && obj.pressed) {
    synth.triggerRelease(obj.note)
    obj.pressed = false
  }
}
  
function adjustLevels (ch, val) {
  
}
  
function handleMidi (m) {
  // console.log(m)
  // Tried to import this but couldn't. pulling directly: https://github.com/notthetup/midimessage/blob/gh-pages/dist/index.js
  console.log(m.messageCode)
  switch (m.messageCode) {

  // Note On
  case 0x90:
    console.log("note on");
    const key = event.data[1] & 0x7F;
    const velocity = event.data[2] & 0x7F;
    if (velocity === 0) {
      midiRelease (key)
    }
    else {
      midiAttack (key)
    }
    break;


  // Control Change
  case 0xB0:
    console.log('control change')
    const controllerNumber = event.data[1] & 0x7F;
    const controllerValue = event.data[2] & 0x7F;
    adjustLevels(ch, val)
    break;
  }
  // if (m.val === 0) {
  //   midiRelease (m)
  // }
  // else {
  //   midiAttack (m)
  // }
}

// event listeners
nn.on('keydown', keyboardAttack)
nn.on('keyup', keyboardRelease)
myMIDI(handleMidi)
  
nn.create('h1')
  .content('VO-0')
  .css( { "text-align":"center" } )
  .addTo('body')  
  
// we can create HTML elements with "nn"
nn.create('button')// what we want to make
  .set({ id: 'upload-btn' })
  .content('Upload Image') // what we want it to say
  .addTo('body')       // where we want to put it

const fu = new nn.FileUploader({
  maxSize: 10000,
  types: ['image/jpeg', 'image/png'],
  click: '#upload-btn',
  ready: (file) => {
    console.log(`the data for the ${file.type} file called ${file.name} is ready`)
    console.log(file.data)
    displayImage(file)
  },
  error: (err) => {
    console.error(err)
  }
})

function slider(name) {
  nn.create('div')
    .set({ id:name })
    .addTo('body')
  const inputName = `${name}-input`
  nn.create('label')
    .set({ 'for':inputName })
    .content(name.toUpperCase())
    .addTo(`#${name}`)
  nn.create('input')
    .set({ type:'range', id:inputName, min:0, max:100, readonly:"readonly"})
    .content(`${name.toUpperCase()}`)
    .addTo(`#${name}`)
}
  
sliders.forEach((s) => slider(s))
  
nn.create('img')
    .set({ src: 'https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fc4.wallpaperflare.com%2Fwallpaper%2F23%2F13%2F163%2Fa-beautiful-village-in-a-natural-forest-wallpaper-preview.jpg&f=1&nofb=1&ipt=4986ba5755d36278c8b3f55db154a3789520ca8dc6e2f963245f8f46c5d0dfdc&ipo=images', id:'theImage'})
    .addTo('body')


</script>